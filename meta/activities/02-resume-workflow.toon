id: resume-workflow
version: 2.3.0
problem: The user wants to continue a workflow that was previously started.
recognition[6]:
  - Resume workflow
  - Continue workflow
  - Restart workflow
  - Pick up where I left off
  - Continue the work-package
  - Where were we?
skills:
  primary: workflow-execution
  supporting[1]:
    - activity-resolution
mandatory_guide:
  workflow_id: work-package
  index: "18"
outcome[4]:
  - Previous state is restored or reconstructed
  - Current phase is identified
  - Remaining work is presented
  - Agent is ready to continue guiding user
flow[14]:
  - 1. Ask user to identify the workflow being resumed
  - 2. Call get_workflow to load workflow definition
  - 3. Call list_guides to discover available guidance
  - "4. Reconstruct state by asking user (use numeric indices):"
  - "   - Which phase were you on? (e.g., phase 3)"
  - "   - What phases have been completed? (e.g., [1, 2])"
  - "   - Any key decisions already made?"
  - 5. Build state object using state_schema below
  - 6. Call get_phase for current phase index
  - "7. Call get_guide for phase-specific guide if available"
  - "8. Present current phase status:"
  - "   - Completed steps (by index within phase)"
  - "   - Remaining steps"
  - "   - Upcoming checkpoints"
  - 9. Resume execution from current position
context_to_preserve[6]:
  - workflowId - The workflow being resumed
  - currentPhase - Phase index to resume from (1-based integer)
  - completedPhases - Array of completed phase indices
  - checkpointResponses - Previous user decisions (keyed by "phase-checkpoint")
  - variables - Current variable values
  - guides - Available guide indices for reference
state_schema:
  description: |
    State uses numeric indices (1-based) for phases and steps.
    When reconstructing state, convert user descriptions to numeric indices.
  reconstructed_state:
    workflowId: workflow.id
    workflowVersion: workflow.version
    stateVersion: 1
    startedAt: "original start time or now()"
    updatedAt: now()
    currentPhase: "integer from user (e.g., 3)"
    currentStep: "integer from user or 1"
    completedPhases: "integer[] from user (e.g., [1, 2])"
    skippedPhases: "integer[] if any phases were skipped"
    completedSteps: "Record<phaseIndex, stepIndex[]>"
    checkpointResponses: "Record<'phase-checkpoint', Response>"
    decisionOutcomes: "Record<'phase-decision', Outcome>"
    activeLoops: []
    variables: "reconstructed from user input"
    history: "reconstructed or start fresh"
    status: running
  key_fields:
    currentPhase: "integer (1-based index)"
    currentStep: "integer (1-based index within current phase)"
    completedPhases: "integer[] (array of completed phase indices)"
    completedSteps: "Record<phaseIndex, stepIndex[]> (e.g., {'1': [1, 2]})"
    checkpointResponses: "Record<'phase-checkpoint', Response> (e.g., {'1-1': {...}})"
    status: "enum: running, paused, completed, aborted, error"
