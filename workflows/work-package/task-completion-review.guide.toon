id: task-completion-review
version: 1.0.0
title: Task Completion Review Guide
purpose: Define the review process performed upon completing each implementation task including verification, assumption surfacing, and quality checks

applicability: "After completing each implementation task."

sections[8]:
  - id: overview
    title: Overview
    content: """
      **After completing each task, perform a task completion review before requesting user confirmation.** This step catches errors, surfaces assumptions, and ensures all changes are grounded in the actual codebase.

      The task completion review has three mandatory components:
      1. **Symbol Verification** — Ensure all symbols have provenance in the codebase
      2. **Assumption Review** — Surface implicit design decisions for user validation
      3. **Quality Checks** — Verify code meets quality standards
    """

  - id: symbol-verification
    title: Symbol Verification
    subsections[4]:
      - id: what-is
        title: What is Symbol Verification?
        content: """
          **Every symbol (type, function, constant, field, etc.) introduced or referenced in code or documentation MUST have provenance in the actual codebase.**

          **Provenance means:**
          - The symbol exists in the codebase (can be found via grep/search)
          - The symbol exists in a declared dependency (verified in Cargo.toml, package.json, etc.)
          - The symbol is being newly created by the current task (and is correctly defined)
        """

      - id: critical
        title: "⚠️ CRITICAL: Never Fabricate Symbols"
        content: """
          **Fabricating symbols is unacceptable.** This includes:
          - Inventing type names, trait names, or struct names that don't exist
          - Referencing functions or methods that aren't implemented
          - Using field names in documentation that don't match actual code
          - Assuming symbol names based on patterns without verification
          - Renaming symbols in documentation without corresponding code changes
        """

      - id: checklist
        title: Symbol Verification Checklist
        checks[6]{check,howToVerify}:
          New types/structs,Definition exists in committed code
          New functions/methods,Implementation exists in committed code
          New constants/fields,Declaration exists in committed code
          Referenced existing symbols,grep confirms symbol exists in codebase
          Symbols from dependencies,Dependency declared in manifest AND symbol exists in that crate/package
          Symbols in documentation,Every symbol mentioned in docs/ADRs/change files exists in code

      - id: when-fails
        title: When Symbol Verification Fails
        steps[4]:
          - "**Stop immediately** — Do not proceed with the assumption"
          - "**Search more thoroughly** — Try alternative search patterns, check git history"
          - "**Check if it should exist** — Is this something you need to create?"
          - "**Ask the user** — If uncertain, request clarification before proceeding"

  - id: assumption-review
    title: Assumption Review
    intro: "After symbol verification, identify assumptions made during implementation."
    categories[6]{category,description,examples}:
      Behavioral,How the system behaves in specific scenarios,"Default values, fallback behavior, edge case handling"
      Architectural,Structural decisions about components,"Component boundaries, data flow direction, abstraction levels"
      Interface,API and contract decisions,"Function signatures, return types, error types"
      Performance,Trade-offs affecting speed/memory,"Lazy vs eager evaluation, caching strategies, algorithm choice"
      Compatibility,Backward/forward compatibility,"Breaking changes, deprecation handling, migration paths"
      Scope,What was included/excluded,"Deferred features, intentional limitations"
    selfReviewQuestions[5]:
      - "What did I assume about requirements? — Were there ambiguities I resolved without asking?"
      - "What alternatives did I reject? — Why was this approach chosen over others?"
      - "What implicit contracts exist? — Are there undocumented expectations about inputs, ordering, or state?"
      - "What edge cases did I handle (or ignore)? — How will the code behave in unexpected situations?"
      - "What would I do differently with more context? — Are there decisions I'm uncertain about?"

  - id: quality-checks
    title: Quality Checks
    subsections[3]:
      - id: code-quality
        title: Code Quality Checklist
        items[7]:
          - Follows existing patterns and architecture
          - Type-safe (compiler checks pass)
          - Error handling implemented
          - No hardcoded values (use constants or configuration)
          - Documentation comments on public APIs
          - No debug prints in production code
          - No TODO comments without issue references

      - id: test-quality
        title: Test Quality Checklist
        items[4]:
          - Unit tests written for new code
          - Edge cases covered
          - Error conditions tested
          - All tests passing (unit, integration, e2e)

      - id: doc-quality
        title: Documentation Quality Checklist
        items[4]:
          - All symbols in docs exist in code (see Symbol Verification)
          - Change file accurately describes actual changes
          - No fabricated or speculative content
          - Commit messages follow conventional commits

  - id: self-review-process
    title: Self-Review Process
    flow: """
      1. SYMBOL VERIFICATION
         ├─ List all new symbols introduced
         ├─ Verify each exists in code or dependencies
         ├─ Check documentation references actual symbols
         └─ If any symbol cannot be verified → STOP

      2. ASSUMPTION REVIEW
         ├─ Identify design decisions made
         ├─ Categorize each assumption
         ├─ Document rationale
         └─ Prepare for user review

      3. QUALITY CHECKS
         ├─ Run through code quality checklist
         ├─ Run through test quality checklist
         ├─ Run through documentation quality checklist
         └─ Fix any issues before checkpoint

      4. CHECKPOINT
         └─ Present findings to user for confirmation
    """

  - id: anti-patterns
    title: Anti-Patterns
    patterns[6]{dont,why}:
      Skip symbol verification,"Fabricated symbols create incorrect documentation"
      Assume symbol names from patterns,Symbol naming varies; always verify with grep
      "Reference 'planned' but unimplemented symbols","Documentation must reflect actual code, not intentions"
      Skip self-review after each task,Hidden errors compound; early detection saves time
      Proceed when symbol cannot be verified,Stop and investigate; the symbol may not exist
      Document symbols from memory,Always verify against actual code

  - id: quick-reference
    title: Quick Reference
    mandatorySteps[4]:
      - "✅ **Symbol Verification** — All symbols have provenance"
      - "✅ **Assumption Review** — Design decisions documented"
      - "✅ **Quality Checks** — Code, tests, docs meet standards"
      - "✅ **User Checkpoint** — Confirmation before proceeding"
    keyCommands: """
      # Verify symbol exists
      grep -r "SymbolName" --include="*.rs" .

      # Check git history for removed symbols
      git log --all --oneline -S "SymbolName" -- "*.rs"

      # Compare branch to main for new symbols
      git diff origin/main -- "*.rs" | grep "^+"
    """

  - id: related-guides
    title: Related Guides
    guides[3]:
      - workflow://work-package/guides/assumptions-review
      - workflow://work-package/guides/work-package
      - workflow://work-package/guides/architecture-review
