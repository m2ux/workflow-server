id: ensemble-pass
version: 2.3.0
name: Ensemble Pass
description: "Optional second-model audit run on priority-1/2 components. Merges findings with the primary report using union-with-consensus-severity strategy. Fully automated — no user checkpoints."
problem: Different models and configurations find different subsets of findings. Running the template a second time and merging results captures findings that are non-deterministically detected in any single run, improving overall coverage.
recognition[3]:
  - run ensemble pass
  - second model audit
  - multi-model merge
skills:
  primary: execute-audit
  supporting[1]:
    - score-severity
required: false
estimatedTime: 60-90m
rules[9]:
  - "This activity is OPTIONAL — only runs when ensemble_enabled is true"
  - "Scope the second pass to priority-1/2 components only to control cost"
  - "Use a different model or temperature if available; same model with different system prompt is acceptable"
  - "The merge strategy is union: include all findings from both runs, flag consensus vs single-source"
  - "EXECUTION VERIFICATION (v4.4): The ensemble pass MUST dispatch at least one sub-agent that independently applies the §3 checklist to priority-1/2 crates. Declaring the ensemble complete without dispatching any sub-agents violates this activity. The execute-second-pass step is the core of this activity — it is not optional."
  - "ARTIFACT REQUIREMENT (v4.4): The execute-second-pass step MUST produce a second-pass-findings artifact (MD or JSON) in the planning folder. This artifact is the verification mechanism — if it does not exist when the activity exits, the ensemble was not executed. The orchestrator checks for this artifact during the update-report step."
  - "CONTEXT CONSTRAINT HANDLING (v4.4): If context window pressure prevents executing a full second pass, the orchestrator MUST: (a) explicitly acknowledge the constraint, (b) scope the second pass to the top 3-5 files by priority rather than skipping entirely, and (c) produce the artifact even if the scope is reduced. A reduced-scope ensemble is always preferable to a skipped ensemble."
  - "TARGETED BLIND-SPOT VERIFICATION (v4.7 — expanded from 4 to 9 items): The ensemble agent checks these items FIRST before performing general review: (1) §3.1 weight accounting — read weights.rs and verify non-zero return value for on_finalize; (2) §3.3 event filtering on partial success — trace EVERY event field independently, not just UTXOs; verify coverage spans ALL event construction sites (NTO events, midnight pallet events, model.rs export_events); (3) §3.2 pagination counter initialization — trace first-iteration behavior of cur_tx or equivalent; (4) §2.10 serialization buffer pairing — compare size function name against serialize function name character by character and produce the pairing table; (5) §3.10 timestamp source in cross-chain pallets (v4.7) — search pallet_timestamp in every pallet that processes external-chain inherent data; if found, trace whether it enters cross-chain event/payload construction; DEFAULT FAIL for cross-chain pallets; (6) §3.4 VerifierCIDP recomputation (v4.7) — for every type in proposer but not verifier, cite the specific verifier recomputation code path; 'value from digest' is not recomputation; (7) §3.14 system transaction type exhaustiveness (v4.7) — search for wildcard _ => match arms in apply_system_transaction; wildcard = FAIL; (8) Check 15: SSL/TLS mode (v4.7) — search PgPoolOptions construction, verify explicit ssl_mode call; (9) Check 16: Host function feature divergence (v4.7) — search HostFunctions type aliases gated by features. Each item produces CONFIRMED/REFUTED/INSUFFICIENT verdict. Items 5-9 are new in v4.7 to catch findings that are non-deterministically missed by primary-pass agents due to reasoning variance."
  - "ENSEMBLE SUPPLEMENTARY FILES (v4.7): The ensemble agent MUST receive these supplementary files explicitly: (a) pallets/midnight/src/weights.rs for weight verification; (b) runtime/src/model.rs for export_events verification; (c) ledger/src/versions/common/api/mod.rs for serialization pairing verification; (d) primitives/mainchain-follower/src/data_source/mod.rs for SSL mode and pagination verification; (e) node/src/inherent_data.rs for VerifierCIDP recomputation verification; (f) pallets/midnight-system/src/lib.rs or the relevant apply_system_transaction code for type exhaustiveness. Including these files ensures the blind-spot checklist items can be mechanically verified without depending on the agent to discover them independently."
steps[5]:
  - id: configure-ensemble
    name: Configure Ensemble Run
    description: "Determine the scope (priority-1/2 components only), model configuration, and any prompt variations for the second pass. Include the targeted blind-spot checklist and mandatory supplementary files (weights.rs, model.rs, api/mod.rs) in the agent prompt."
  - id: verify-blind-spots
    name: "Verify Known Blind Spots (v4.6)"
    required: true
    description: "Before general review, the ensemble agent applies the targeted blind-spot checklist (9 items): (1) Read weights.rs — does WeightInfo::on_finalize() return non-zero Weight? (2) Read model.rs export_events — are NativeTokenObservation/NativeTokenManagement events handled (not unimplemented!())? Are all event fields filtered on partial success? (3) Read pagination code — trace first-iteration behavior of cur_tx or equivalent. (4) Read serialization code — produce the mandatory size-function/serialize-function pairing table. (5) Search pallet_timestamp in cross-chain pallets — if found in event/payload construction for external-chain data, FAIL. (6) Compare ProposalCIDP vs VerifierCIDP — cite specific recomputation code for each asymmetry. (7) Search apply_system_transaction for wildcard match arms — wildcard = FAIL. (8) Search PgPoolOptions construction — verify explicit ssl_mode call. (9) Search HostFunctions type aliases gated by features — divergence = FAIL. Each blind-spot item produces a CONFIRMED/REFUTED/INSUFFICIENT verdict. REFUTED items become findings."
  - id: execute-second-pass
    name: Execute Second Pass
    description: "Run the audit template against priority-1/2 components. The second pass follows the same §3 checklist and §5 execution requirements."
  - id: union-merge
    name: Union-Merge Findings
    skill: merge-findings
    skill_args:
      merge_strategy: union-merge
    description: "Merge second-pass findings with the primary report using union strategy."
  - id: update-report
    name: Update Report
    description: "Update 01-audit-report.md with ensemble results. Add a section noting which findings are consensus (both runs) vs single-source (one run only)."
decisions[1]:
  - id: next-phase
    name: Post-Ensemble Decision
    description: Route to gap analysis or completion
    branches[2]:
      - id: gap-analysis
        label: Run gap analysis
        condition:
          type: simple
          variable: has_reference_report
          operator: ==
          value: true
        transitionTo: gap-analysis
      - id: complete
        label: Audit complete
        isDefault: true
transitions[2]:
  - to: gap-analysis
    condition:
      type: simple
      variable: has_reference_report
      operator: ==
      value: true
  - to: gap-analysis
    isDefault: true
exitActions[1]{action,message}:
  log,Ensemble pass complete — findings merged with primary report
outcome[3]:
  - Second-pass findings merged with primary report
  - Findings classified as consensus or single-source
  - Escalated findings (PASS in primary, FAIL in ensemble) added
context_to_preserve[3]:
  - consensus_findings - Findings confirmed by both runs
  - single_source_findings - Findings from only one run
  - escalated_findings - PASSes in primary that became FAILs in ensemble
artifacts[1]:
  - id: second-pass-findings
    name: second-pass-findings.md
    location: planning
    description: "Raw findings from the second-pass audit run. Existence of this file verifies the ensemble was actually executed. Must contain at least one sub-agent dispatch result."
