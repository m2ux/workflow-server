id: adversarial-verification
version: 2.0.0
name: Adversarial Verification
description: "Verify every PASS item from the primary audit scratchpads by decomposing each claim into constituent properties, enumerating all fields/sites, and independently verifying each one. The agent's role is to REFUTE, not confirm. Fully automated — no user checkpoints."
problem: AI agents exhibit first-positive-signal bias — they find one correct behavior and mark the entire check as PASS without verifying all related fields or paths. This consistently causes Medium/High findings to be missed as false PASSes.
recognition[3]:
  - verify audit findings
  - adversarial review
  - check pass items
skills:
  primary: audit-execution
required: true
estimatedTime: 30-60m
notes[6]:
  - "This agent's role is to REFUTE safety claims, not confirm them"
  - "Focus on §3.1 (flush), §3.2 (lifecycle/cursor), §3.3 (event fields), §3.4 (inherent symmetry), §3.6 (input validation), §3.10 (timestamps) — these checks are most susceptible to false PASSes"
  - "A PASS that says 'events are filtered' must be decomposed: are UTXOs filtered? Are call_addresses filtered? deploy_addresses? maintain_addresses? claim_rewards? Each field independently."
  - "A PASS that says 'cursor is set correctly' must verify: is there an ensure!(new > old) guard? If not, the PASS is invalid regardless of whether the code 'works'"
  - "Output CONFIRMED only when ALL decomposed properties are verified with code citations"
  - "CONTAMINATION GUARD: DO NOT read, open, fetch, or query any reference audit report or prior gap analysis. The adversarial agent must verify PASS claims using ONLY the source code — never by checking whether a professional auditor found the same issue."
entryActions[1]{action,message}:
  log,Starting adversarial verification of PASS items
steps[5]:
  - id: extract-pass-items
    name: Extract PASS Items
    description: "Collect every §3 checklist item marked PASS from all agent scratchpads. Filter to items with severity >= Medium potential (§3.1-§3.4, §3.6, §3.8, §3.10, §3.14)."
  - id: decompose-claims
    name: Decompose PASS Claims
    description: "For each PASS item, enumerate the specific properties the PASS requires to be true. Example: 'events filtered for failed segments' requires 5 independent properties (UTXO data, call_addresses, deploy_addresses, maintain_addresses, claim_rewards)."
  - id: field-enumeration
    name: Enumerate Multi-Site Properties
    description: "For every PASS involving multiple fields, sites, or instances (e.g., 'events filter by outcome', 'addresses are validated', 'subscriptions have limits'), enumerate ALL instances and verify each independently. A single-instance verification is INSUFFICIENT for a PASS. Produce a structured table: | Instance | Verified? | Evidence | for each."
  - id: verify-properties
    name: Verify Properties Independently
    description: "For each decomposed property, read the cited code location and search for the specific implementation. If any property lacks implementation, output REFUTED with evidence."
  - id: compile-results
    name: Compile Verification Results
    description: "Produce structured output: CONFIRMED (all properties verified), REFUTED (finding with evidence), or INSUFFICIENT (cannot determine). Every REFUTED item becomes a new finding."
transitions[1]{to,isDefault}:
  report-generation,true
exitActions[2]{action,message}:
  log,Adversarial verification complete — {refuted_count} false PASSes identified
  set,adversarial_complete=true
outcome[3]:
  - Every High/Medium PASS item decomposed and independently verified
  - False PASSes identified and converted to new findings
  - Verification results documented for report integration
context_to_preserve[3]:
  - confirmed_passes - PASS items verified as correct with evidence
  - refuted_passes - False PASSes converted to new findings
  - insufficient_items - Items requiring manual review
