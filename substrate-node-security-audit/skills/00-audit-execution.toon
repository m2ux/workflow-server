id: audit-execution
version: 2.0.0
capability: Execute security audit phases with consistent tool usage, two-wave multi-agent coordination, and mandatory checklist completion

execution_pattern:
  setup[4]:
    - Extract target submodule and commit from initial request — fail if not specified
    - Checkout submodule at target commit
    - Run cargo audit / cargo deny or fallback to manual dependency inspection
    - Create planning folder and initialize artifacts
  reconnaissance[5]:
    - Read workspace Cargo.toml and list all crates
    - Classify crates by type (runtime, native, shared, tooling)
    - Identify trust boundaries and consensus paths
    - Build function registry for priority-1/2 crates
    - Generate file inventory sorted by line count and assign two-wave agent groups
  primary_audit[6]:
    - "Wave 1: Dispatch Group A agents (one per priority-1 crate) with §3 checklist, anti-anchoring, and completion gate"
    - "Wave 1: Dispatch Group B agent for §2 static analysis across full scope"
    - "Wave 1: Dispatch Group C agents for cross-cutting traces (pools, genesis, inherents, ordering, timestamps, validation, struct diffs, pagination)"
    - "Wave 2: Dispatch Group A agents (one per priority-2 crate) with §3 checklist, anti-anchoring, and completion gate"
    - "Wave 2: Dispatch Group D agent for toolkit review with minimum checklist (MANDATORY)"
    - "Wave 2: Dispatch Group E agent for mechanical checklist verification (MANDATORY)"
  adversarial[4]:
    - Extract all PASS items from agent scratchpads
    - Decompose each PASS into constituent properties
    - Enumerate all fields/sites for multi-instance properties
    - Verify each property independently — output CONFIRMED/REFUTED/INSUFFICIENT
  consolidation[5]:
    - Merge findings from all agents and phases
    - Deduplicate by root cause
    - Apply severity scoring rubric (Impact x Feasibility)
    - Severity cross-check for findings with Impact >= 3
    - Verify coverage gate (§5.14)

tools:
  read_file:
    when: Reading source code files for manual review
    params: file_path
    returns: File contents
    usage: Read every .rs file in assigned crate; prioritize files >200 lines
  grep:
    when: Running §2 static analysis patterns
    params: pattern, scope, exclusions
    returns: Matching lines with file paths and line numbers
    usage: Run against FULL in-scope directory set, not selectively
  shell:
    when: Running cargo audit, cargo deny, git operations, file inventory
    params: command
    returns: Command output
    usage: Capture and save output to planning folder
  task:
    when: Dispatching sub-agents for crate-level review or trace analysis
    params: description, prompt, subagent_type
    returns: Sub-agent findings and scratchpad
    usage: Use generalPurpose for deep review agents; explore for quick searches

agent_dispatch:
  group_a:
    description: Crate-level deep review agents
    count: One per priority-1/2 crate
    wave: "Priority-1 in Wave 1, priority-2 in Wave 2"
    receives: "Crate path, relevant §3 checklist sections from the template, function registry entries, invariant extraction requirement, in_scope/out_of_scope paths"
    must_do[7]:
      - "Load the audit template content provided by the orchestrator (sub-agents do NOT load the template independently)"
      - Read every .rs file in the crate including large submodules
      - Perform invariant extraction for every priority-1 function (§5.15)
      - Apply every applicable §3 check with evidence-based PASS/FAIL/NA
      - "ANTI-ANCHORING: When checking multi-field properties, check EVERY field independently. Produce a per-field table."
      - "COMPLETION GATE: Before returning, verify PASS/FAIL/NA for EVERY numbered checklist item. List unevaluated items."
      - Return structured findings and completed scratchpad
  group_b:
    description: Static analysis agent
    count: 1
    wave: Wave 1
    receives: "Full in-scope directory set, all §2 grep patterns"
    must_do[2]:
      - Run every §2 pattern against ALL in-scope directories
      - Return categorized hits with triage by reachability
  group_c:
    description: Cross-cutting trace agents
    count: 5-8 depending on codebase
    wave: Wave 1
    traces[8]:
      - Connection pool tracer — pool creation to all consumers via .clone()
      - Genesis consistency tracer — StorageInit across all code paths
      - Inherent symmetry tracer — proposer vs verifier tuple field-by-field
      - "Ord/PartialOrd completeness verifier — every impl Ord checked for full field coverage in cmp()"
      - Timestamp source tracer — layer-by-layer clock verification
      - Input validation tracer — entry-to-consumption validation chain
      - Struct diff agent — event struct vs storage struct field comparison
      - Pagination loop tracer — counter initialization, termination, and end-position across all layers
  group_d:
    description: Toolkit review agent
    count: 1
    wave: Wave 2
    mandatory: true
    receives: "ledger/helpers/ and util/toolkit/ paths, toolkit minimum checklist (resource 03)"
    must_do[2]:
      - Read all toolkit .rs files
      - Apply the 7-item mandatory toolkit checklist
  group_e:
    description: Mechanical checklist verification agent
    count: 1
    wave: Wave 2
    mandatory: true
    receives: "All §2 grep patterns historically missed, plus mechanical §3 checks"
    must_do[6]:
      - "Search every impl Ord/PartialOrd and verify all struct fields are included in cmp()"
      - "Search for take_while(Result::is_ok) and filter_map(Result::ok) patterns"
      - "Search for Vec::with_capacity(serialized_size) vs tagged_serialized_size mismatches"
      - "Search for subscribe/notification_service/justification_stream for fan-out limits"
      - "Enumerate every StorageInit construction site and verify genesis source consistency"
      - "Return PASS/FAIL per pattern with line citations"

state:
  track[6]:
    - current_phase - Which phase is active (setup, reconnaissance, primary, adversarial, report, ensemble, gap)
    - agent_status - Status of dispatched sub-agents across both waves
    - findings_count - Running count of identified findings
    - pass_count - Running count of PASS items in scratchpads
    - coverage_files - List of files read by agents
    - scratchpad_items - Collected PASS/FAIL/NA items from all agents

errors:
  submodule_not_found:
    cause: Target submodule path does not exist
    recovery: Fail with descriptive error — do not ask interactively
  commit_not_found:
    cause: Target commit hash not found in submodule history
    recovery: Fail with error showing recent commits via git log
  template_not_found:
    cause: Audit prompt template not at expected path
    recovery: Fail with error showing expected path
  agent_timeout:
    cause: Sub-agent did not return within expected time
    recovery: Check terminal output; resume or re-dispatch the agent
