id: execute-audit
version: 3.0.0
capability: Execute security audit phases with consistent tool usage, concurrent multi-agent coordination, and §3 checklist completeness verification

resources[1]:
  - "04"

protocol:
  setup[4]:
    - Extract target submodule and commit from initial request — fail if not specified
    - Checkout submodule at target commit
    - Run cargo audit / cargo deny or fallback to manual dependency inspection
    - Create planning folder and initialize artifacts
  reconnaissance[5]:
    - Read workspace Cargo.toml and list all crates
    - Classify crates by type (runtime, native, shared, tooling)
    - Identify trust boundaries and consensus paths
    - Build function registry for priority-1/2 crates
    - Generate file inventory sorted by line count and assign agent groups (A, B, D)
  primary_audit[5]:
    - Dispatch all primary agents (A1-A6, B, D) concurrently with §3 checklist, cross-crate supplementary files, and toolkit minimum checklist
    - Collect all results from primary agents
    - Dispatch verification sub-agent (V) to validate output completeness against target profile, act on gap report, extract table-derived findings
    - Re-dispatch targeted follow-up agents for any gaps identified by the verification agent
    - Structured-merge all findings (primary + follow-up + table-derived) into flat table, dedup-and-map to report findings, verify §3 completeness
  adversarial[4]:
    - Extract all PASS items from agent scratchpads
    - Decompose each PASS into constituent properties
    - Enumerate all fields/sites for multi-instance properties
    - Verify each property independently — output CONFIRMED/REFUTED/INSUFFICIENT
  consolidation[4]:
    - Integrate adversarial results into structured merge table
    - Apply severity scoring rubric (Impact x Feasibility) with calibration example cross-check
    - Verify coverage gate (§5.14)
    - Verify elevation completeness via merge table mapping

tools:
  read_file:
    when: Reading source code files for manual review
    params: file_path
    returns: File contents
    usage: Read every .rs file in assigned crate; prioritize files >200 lines
  grep:
    when: Running §2 static analysis patterns and mechanical checks
    params: pattern, scope, exclusions
    returns: Matching lines with file paths and line numbers
    usage: Run against FULL in-scope directory set, not selectively
  shell:
    when: Running cargo audit, cargo deny, git operations, file inventory
    params: command
    returns: Command output
    usage: Capture and save output to planning folder
  task:
    when: Dispatching sub-agents for crate-level review or analysis
    params: description, prompt, subagent_type
    returns: Sub-agent findings and scratchpad
    usage: Use generalPurpose for deep review agents; explore for quick searches

state:
  track[6]:
    - current_phase - Which phase is active (setup, reconnaissance, primary, adversarial, report, ensemble, gap)
    - agent_status - Status of dispatched sub-agents
    - findings_count - Running count of identified findings
    - pass_count - Running count of PASS items in scratchpads
    - coverage_files - List of files read by agents
    - checklist_coverage - §3 coverage matrix showing per-item evaluation status

errors:
  submodule_not_found:
    cause: Target submodule path does not exist
    recovery: Fail with descriptive error — do not ask interactively
  commit_not_found:
    cause: Target commit hash not found in submodule history
    recovery: Fail with error showing recent commits via git log
  template_not_found:
    cause: Audit prompt template not at expected path
    recovery: Fail with error showing expected path
  agent_timeout:
    cause: Sub-agent did not return within expected time
    recovery: Check terminal output; resume or re-dispatch the agent
