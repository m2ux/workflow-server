id: verify-sub-agent-output
version: 1.4.0
capability: "Validate that sub-agent results meet structural completeness requirements, check coverage gates and mandatory output tables, and flag or re-dispatch on failure"

description: "A reusable verification skill for multi-agent workflows. After collecting sub-agent results, this skill defines how to check that each agent's output contains all required tables, covers all expected files, and meets structural completeness criteria. Missing outputs are flagged for targeted re-dispatch."

resources[1]:
  - "04"

inputs[5]:
  - id: agent-results
    description: "Collected structured outputs from sub-agents"
    required: true
  - id: expected-outputs
    description: "Per-agent list of required tables, coverage criteria, and completeness checks"
    required: true
  - id: file-inventory
    description: "List of files that must be covered (for coverage gate verification)"
    required: false
  - id: dispatch-manifest
    description: "Dispatch manifest from the dispatch-sub-agents skill showing assigned vs dispatched agents"
    required: false
  - id: agent-assignments
    description: "Crate-to-agent-group assignments from reconnaissance"
    required: false

protocol:
  check-dispatch-completeness[1]:
    - "If a dispatch_manifest is provided, verify every agent in the agent_assignments was dispatched and returned. Produce a dispatch status table: crate, assigned_group, agent_dispatched (yes/no), structured_output_received (yes/no). If any assigned agent was not dispatched, flag as DISPATCH_INCOMPLETE. This is a HARD STOP — the orchestrator must dispatch missing agents before proceeding."
  check-coverage-gate[1]:
    - "For each .rs file exceeding 200 lines in priority-1/2 crates, check whether at least one §3-APPLYING GROUP A SUB-AGENT's output references it (via file manifest, findings, or checklist coverage). Files read ONLY during reconnaissance (by the orchestrator or reconnaissance sub-agents) do NOT satisfy the coverage gate. Produce a coverage table: file, lines, read-by-agent, agent_type (group-a/recon/none), status (COVERED/RECON-ONLY/UNREAD). Flag any file with status RECON-ONLY or UNREAD. This is a HARD STOP."
  check-mandatory-tables[1]:
    - "For each agent, check that every required table exists in the agent's result. Required tables are determined by the agent's vulnerability domain map entries: (a) §3 checklist evaluation table for all crate-review agents; (b) per-field event trace table AND event-vs-storage struct diff table for agents with §3.3 domain entries; (c) cross-function invariant table for agents with §3.2 domain entries; (d) cross-layer verification matrix for agents with cross-crate domain entries (§3.2 pagination, §3.10 timestamp); (e) genesis construction site enumeration for agents with §3.5 domain entries; (f) function enumeration table, per-function checklist matrix, and coverage attestation from the toolkit review agent. If any required table is missing or was replaced with prose, flag the agent and table for re-dispatch."
  check-structural-completeness[1]:
    - Check that each agent's steps_completed list matches the activity definition. Check that every FAIL verdict has a corresponding finding entry. Check that every mandatory_tables field is populated or null with justification.
  check-cross-chain-timestamp[1]:
    - "For every Group A agent reviewing a pallet that processes inherent data from an external chain (specifically: NTO pallet, any bridge pallet), verify the agent's output includes a cross-layer timestamp verification matrix with explicit per-layer verdicts. If the agent marked §3.10 as PASS without producing this matrix, flag for re-dispatch."
  extract-table-findings[1]:
    - "DETERMINISTIC CELL-LEVEL SCAN: Iterate every row in every mandatory table from every agent. For each cell, apply keyword match: FAIL, DIFF, Missing, No, absent, not validated, unconditional, no guard, no check, unpaired. Each matching cell becomes a table-derived finding (source_table, cell_description, agent_id, severity=TBD). The orchestrator MUST NOT apply judgment to skip cells — all matches are extracted. Deduplication occurs later in merge-findings."
  verify-event-construction-site[1]:
    - For every pallet that calls deposit_event() with data derived from transaction results, verify that the Group A agent's §3.3 per-field trace table covers ALL event construction sites identified in the vulnerability domain map. If the trace table covers only one site when multiple exist, dispatch a targeted follow-up agent for the uncovered sites.
  check-config-variant-triage[1]:
    - "For the node binary agent (A3 or equivalent), verify its output includes a configuration-variant triage table that maps each expect()/unwrap() in service initialization code to all valid configuration modes (InMemory, OnDisk, pruned, archive, development). If the table is absent or covers fewer than 80% of expect()/unwrap() sites in service.rs and command.rs, flag for re-dispatch with explicit Check 25 instructions."
  check-genesis-parsing-coverage[1]:
    - "For the node binary agent (A3 or equivalent), verify its output traces ALL four genesis data parsing paths: (1) StorageInit construction sites (existing §3.5 check), (2) genesis extrinsics decoding from chain spec properties, (3) genesis header construction (including feature-gated digest items), (4) chain spec property extraction (JSON parsing of genesis_state, genesis_block, etc.). Each path must have a truncation-safety verdict. If any path is untraced, flag for re-dispatch with explicit Check 26 instructions."
  check-error-path-persistence[1]:
    - "For each Group A pallet agent, verify that every StorageMap::insert() site identified in the agent's storage lifecycle pairing table has been checked for error-path persistence: does a subsequent fallible operation (host API call, event construction, serialization) exist on the same code path? If so, does the error path revert the insert? If the agent's output does not address error-path persistence for any insert site, flag for follow-up. This specifically targets the pattern where insert() persists but the handler returns None on a downstream failure."
  produce-verification-report[1]:
    - "Output a structured report listing: dispatch completeness status, all coverage gaps (files not read by §3-agents), all missing tables (agent + table ID), all structural issues, cross-chain timestamp check status, table-derived findings from extract-table-findings step, event construction site coverage status. For each gap, recommend a targeted follow-up dispatch."

output[1]:
  - id: verification-report
    description: "Verification report with gap list and re-dispatch recommendations."
    components:
      dispatch_manifest: "crate, assigned_group, dispatched, returned, status"
      coverage_table: "file, lines, agent, agent_type (group-a/recon/none), COVERED/RECON-ONLY/UNREAD"
      missing_tables_list: "agent_id, table_id, reason"
      redispatch_recommendations: "agent_id, scope, specific check to perform"

errors:
  dispatch_incomplete:
    cause: "One or more assigned agents were not dispatched"
    recovery: "HARD STOP — dispatch missing agents before proceeding to structured-merge"
  coverage_gate_failure:
    cause: "One or more files were read only during reconnaissance, not by §3-applying agents"
    recovery: "Dispatch targeted Group A follow-up agents for RECON-ONLY files before proceeding"
  missing_mandatory_table:
    cause: "An agent returned prose instead of a required structured table"
    recovery: "Re-dispatch the agent with explicit output format instructions"
